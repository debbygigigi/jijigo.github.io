{"pages":[],"posts":[{"title":"vue + socket.io = chatroom","text":"前言因為看了吳大師的 [週四寫程式系列] 來用socket.io做個即時互動的遊戲吧！ Youtube直播，對這個主題很有興趣很想來挑戰本來想說應該不會太難，老師直播才用了一小時，那我兩小時應該可以吧～結果雖然頁面做得很快，但想要deploy到heroku上debug就花了將近一個禮拜的晚上（哭） 準備使用 vue-cli 的template建立新專案 1vue init webpack-simple vue-chatroom 安裝套件 1npm install express socket.io --save server端首先在專案的根目錄下建一個跑後端的檔案 server.js這個server.js主要要建立 socket server，並幫我們導向靜態頁面 server.js1234567891011121314151617181920const express = require('express');const socketIO = require('socket.io');const path = require('path');const serveStatic = require('serve-static');const PORT = process.env.PORT || 3000;// 建立http server const server = express() .use(\"/\", serveStatic(path.join(__dirname, '/dist'))) .listen(PORT, () =&gt; console.log(`Listening on $&#123; PORT &#125;`));// 建立socket server const io = socketIO(server);// 處理socket連線事件io.on('connection', (socket) =&gt; &#123; console.log('Client connected'); socket.on('disconnect', () =&gt; console.log('Client disconnected'));&#125;); 因為我的 index.html位置在/dist下，透過 serveStatic 這個套件幫我導向 client端安裝套件 socket.io-client1npm i socket.io-client app.vue12import io from \"socket.io-client\";var socket = io(); 如果你的socket server跟client是分開的io() 括號內可以填入socket server的網址如果沒填就是預設連到目前的網址 測試連線server端跟client端的基本設置就完成了現在只要開啟server就能知道有無連線成功 1node server.js 如果terminal有出現 Client connected 就是連線成功！ 測試接收訊息在client端連線後，emit訊息到server 12var socket = io();socket.emit(&quot;message&quot;, &quot;hello world.&quot;); server端用on接收，後面接callback function1234567io.on(&apos;connection&apos;, function (socket) &#123; console.log(&apos;a user connected.&apos;); socket.on(&apos;message&apos;, (msg) =&gt; &#123; console.log(&apos;user says: &apos; + msg); &#125;);&#125;); terminal出現訊息就代表server接收成功！ 實作功能顯示訊息首先建立 messages 陣列來儲存訊息假設一開始已經有一筆訊息，在一開始連線時就要讓client收到這個歷史訊息 server端 12345678910// 建一個儲存歷史訊息的變數，只要server開著，變數內容就會一直存在const messages = [ &#123; name: 'Majar', message: 'Good Night.' &#125;];io.on('connection', function (socket) &#123; console.log('a user connected.'); // 廣播 歷史訊息 socket.emit('syncMessages', messages);&#125;); client端 先建立簡單的list畫面 App.vue1234567891011&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;聊起來&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;msg in messages&quot;&gt; &#123;&#123; msg.name &#125;&#125;: &#123;&#123; msg.message &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 收到 syncMessages 事件，把訊息資料傳到data去render 1234567891011//...data() &#123; return &#123; messages: [] &#125;; &#125;,created() &#123; socket.on(\"syncMessages\", messages =&gt; &#123; this.messages = messages; &#125;); &#125; client留言接下來就是要讓使用者可以留言 client端寫個簡單的input和button App.vue123&lt;input ref=&quot;name&quot; type=&quot;text&quot; placeholder=&quot;name&quot; value=&quot;路人&quot;&gt;&lt;input ref=&quot;message&quot; type=&quot;text&quot; placeholder=&quot;message&quot;&gt;&lt;button @click=&quot;addMessage&quot;&gt;留言&lt;/button&gt; 按下新增留言按鈕時，emit newMessage 事件，並帶上資料 12345678910methods: &#123; addMessage() &#123; socket.emit(\"newMessage\", &#123; name: this.$refs.name.value, message: this.$refs.message.value &#125;); this.$refs.name.value = \"\"; this.$refs.message.value = \"\"; &#125;&#125; server端 當收到client的訊息時，push至message陣列後並再次廣播到client，確認每個client都有更新到最新訊息 123456// 接收新訊息socket.on('newMessage', (msg) =&gt; &#123; // console.log(msg.name + ' says: ' + msg.message); messages.push(msg); socket.emit('syncMessages', messages);&#125;); 以上基本的的功能就完成了 遇到的問題在deploy的過程中一直遇到問題而且卡關卡很久最困難的是，還是不知道問題出在哪 第一個error讓我以為ㄧ定要有HTTPS，害我還去申請 openSSL 而且還看不是很懂…後來看到官方的這篇 Using WebSockets on Heroku with Node.js，我就跟著它做然後就成功了 原來是因為在看吳老師的影片時，以為ㄧ定要有 socket server 和 api server，而且我把前端路由做在api server上，所以一直出錯後來跟著官方教學用一個socket server並把前端路由做在這邊就可以了我覺得也是因為我對後端的觀念比較不熟才會一直卡關，甚至連google都沒用，因為不知道實際的問題到底在哪早知道有官方教學就能少走好多天的冤枉路啊 後記本來想說先做簡單的功能，deploy上線之後在慢慢增加功能、調整版面真的沒想到deploy花了好多時間（哭） 來小小的寫一下features，希望之後有時間可以完成更多功能！ firebase儲存訊息 有人輸入中 有幾個人在線上","link":"/2018/08/29/vue-chart-room-with-socketio/"},{"title":"Hello World test","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/08/29/hello-world/"},{"title":"vuex two ways data binding","text":"我們都知道vue很大的特性就是可以做到 two-way data binding ，並且很簡單，只要透過 v-model 綁定 data的值即可，如下 1&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt; 12345new Vue(&#123; data: &#123; message: '' &#125;&#125;) 除了form元件（input, textarea, and select）之外，custom component 也可以做到。 不過 Vuex 也想做到 two-way data binding 該怎麼做呢 原來的做法假設目前有一個 component 和一個 vuex ，component 會需要從 vuex 取值也會賦值，也就是想要實現 two-way data binding 簡單的 vuex 範例，state 裡存放 filters 的狀態，透過 actions 跟 mutations 去呼叫並改變 state 值，如果會 vuex 的話應該看得懂 Store.js123456789101112131415161718192021const state = &#123; filters: &#123; type: 'rent', regions: ['七堵區'], keyword: '123' &#125;,&#125;;const actions = &#123; setFilter(&#123;state, commit&#125;, filter) &#123; commit('SET_FILTER', filter); &#125;&#125;;const mutations = &#123; SET_FILTER: (state, filters) =&gt; &#123; _.forEach(filters, (value, key) =&gt; &#123; state.filters[key] = value; &#125;); &#125;&#125;; 這邊是精簡後的 component vue component 123456789101112131415161718192021222324252627&lt;template&gt; &lt;select v-model=\"regions\" /&gt;&lt;/template&gt;export default &#123; data() &#123; return &#123; regions: [] &#125;; &#125;, computed: &#123; ...mapState(&#123; regionsState: state =&gt; state.filters.regions &#125;), &#125;, watch: &#123; regions(value) &#123; this.setFilter(&#123;'regions': value&#125;); &#125; &#125;, created() &#123; this.regions = this.regionsState; &#125;, methods: &#123; ...mapActions(['setFilter']), &#125;&#125;; 來解釋一下，在這個component中，引入了另一個 custom component: select，並跟 data 綁了 v-model由於要實現雙向綁定，分別從vuex取值及賦值 取值：先從 mapState 取值，並在 created 階段時將值給了 data，於是select component便得到初始值賦值：利用 watch 監聽 data 值，只要值有變動，就執行 mapActions 去更動vuex的state 調整經過調整後，程式碼如下 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;select v-model=\"regions\" /&gt;&lt;/template&gt;export default &#123; // data() &#123; // return &#123; // regions: [] // &#125;; // &#125;, computed: &#123; ...mapState(&#123; regionsState: state =&gt; state.Search.filters.regions &#125;), regions: &#123; get() &#123; return this.regionsState; &#125;, set(value) &#123; this.setFilter(&#123;'regions': value&#125;); &#125; &#125; &#125;, // watch: &#123; // regions(value) &#123; // this.setFilter(&#123;'regions': value&#125;); // &#125; // &#125;, // created() &#123; // this.regions = this.regionsState; // &#125;, methods: &#123; ...mapActions('Search', ['setFilter']), &#125;&#125; 一樣是 v-model綁值，只是綁的值改在computed，利用 computed 的 set與get特性來做取值與賦值 取值：從 computed 的 get 取得 mapState賦值：computed 的值若有變動，在 set 去執行 mapActions 這樣就可以少了 data, watch, created 這些程式碼，利用 computed 去做這些事 結尾在會用 vuex 後，其實都是用第一種作法，或是剛好都沒用到 v-model最近在用的時候靈機一想並上網搜尋後，才發現有這樣好用的做法，並且官方 Vuex - Form Handling 其實也有提到 看來真的沒事就要看看官方文件 :smile: 參考 Form Fields, Two-Way Data Binding and Vuex Anyway, this is how to use v-model with Vuex. Computed setter in action. Vuex - Form Handling","link":"/2018/12/19/vuex-two-ways-data-binding/"}],"tags":[{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Vuex","slug":"Vuex","link":"/tags/Vuex/"},{"name":"DataBinding","slug":"DataBinding","link":"/tags/DataBinding/"}],"categories":[]}